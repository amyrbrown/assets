\documentclass{article}
\begin{document}
\title{Software Carpentry: Lessons Learned}
\date{\today}

\author{
  Neil Chue Hong (Software Sustainability Institute / N.ChueHong@epcc.ed.ac.uk)\\
  Katy Huff (University of  Wisconsin / khuff@cae.wisc.edu)\\
  Michael Jackson (Edinburgh Parallel Computing Centre / michaelj@epcc.ed.ac.uk)\\
  Justin Kitzes (University of California, Berkeley / jkitzes@berkeley.edu)\\
  Stephen McGough (University of Newcastle / stephen.mcgough@newcastle.ac.uk) \\
  Lex Nederbragt (University of Oslo / lex.nederbragt@ibv.uio.no)\\
  Ben Waugh (University College London / b.waugh@ucl.ac.uk)\\
  Ethan White (Utah State University / ethan@weecology.org)\\
  Greg Wilson (Software Carpentry / gvwilson@software-carpentry.org)
}

\maketitle

\begin{abstract}
FIXME: what have \emph{we} learned from Software Carpentry?
\end{abstract}

\section{What We Do That's Different}

\begin{itemize}

  \item KH: It's interactive and peer-taught. It's also directed at
    scientists. I don't know of anything that currently does all three
    of those things.

  \item MJ: Teaching tools and technologies by getting the attendees
    to use them, rather than telling the attendees about them. To get
    them doing things, rather than subjecting them to hour after hour
    of slides full of concepts, syntax and command-line excerpts, with
    the occasional practical thrown in like an oasis in an arid
    desert.

  \item JK: The most useful/interesting thing is providing an overall
    structural framework (i.e., the big picture) that shows scientists
    how different types of computing skills/activities fit together to
    improve their work. There are lots of workshops on data analysis
    and other specific topics, but none that I'm aware of that focus
    on describing the house in which you put the different pieces of
    furniture.

  \item LN: Change the way one thinks about going about on the
    command-line/while programming, making it much more logical,
    robust.

  \item EW: The single most interesting thing to me is our emphasis on
    having the students do a lot of hands on work even though it's
    only a two day workshop. I think this really helps the students
    stay engaged and get over the initial hurdles, and I also think
    it's not at all standard for 1-2 day workshops, which tend to be
    mostly power point and talking. On a related note I think the
    emphasis on live coding for lecture is very cool and pretty
    unique).

  \item NCH: I think it's that we teach software development as a tool
    for researchers, rather than teaching python, or git. Although, I
    notice that the opinions to this are divided on the mailing lists,
    and Steve and Mike have noted differences on the curriculums -
    only the UK courses and ones taught by you really seem to focus
    explicitly on the pedagogical teaching, and the ``why it's useful
    for my research''.

  \item ASM: Try to give a motivation for why people should do what we
    are asking them to do rather than just telling them to do so. It
    takes many software developers years to gain an appreciation on
    why we do certain things. We try to give attendees the opportunity
    to gain from our experiences rather than make the same mistakes
    themselves. However, we're talking about intelligent people here
    who want to know why we do something a particular way not just do
    it that way. In essence - continuing the Carpentry metaphor - we
    provide our apprentices with the skills of the trade but also the
    wealth of our experiences.


Alternatively, I'm really keen on the ``blended learning'', and having instructors type (and make mistakes) live.

  \item BW: Different from what? Other {\em programming} courses for
    scientists and others focus on how to write correct code,
    and give the impression that on reaching a certain level of competence
    programmers will no longer make mistakes. We accept that making
    mistakes is inevitable and teach how to detect and diagnose these.
    We also emphasise code maintainability, including readability and
    modular structure, rather than just initial construction.
    Other {\em software engineering} courses are generally not offered
    specifically to scientists, being aimed more at professional
    software developers undertaking larger projects. We show scientists
    who are not specialist programmers how these principles can pay off
    even on small projects, and relate the practices to research issues such as
    reproducibility and provenance.
    
    \item LJW: I think that the most unique thing about Software Carpentry
    is that it is user centered.  Instead of an expert coming in to tell us 
    what we need to know about computing, Software Carpentry tries to build 
    on what we know and tailor the material to the computing needs of researchers' 
    specific environments.

\end{itemize}

\section{What Other People Could Adopt}

\begin{itemize}

  \item KH: I like our github system. I also like your
    teaching.software-carpentry.org lessons/system/pipeline. If I were
    to warn another group I would suggest that they seek out a
    target-audience that is as domain-specific as possible.

    \begin{itemize}

      \item GW: But we \emph{don't} go domain-specific---does that
        mean you'd change what we do?

      \item KH: What I meant was that I would seek out audiences that
        are domain-specific so that any single bootcamp has a better
        chance of being attended by people with a smaller range
        strengths and weaknesses. We can do that more now (and are
        doing it a bit) just by targeted advertising of the
        bootcamps. That is, if we advertise a bootcamp only to physics
        grad students, we can more comfortably teach our curriculum
        with an emphasis on version control rather than the shell
        (since physics grad students are more comfortable in the shell
        than other disciplines). The way you read this suggestion,
        though, is also true. I do think it would be good to generate
        domain-specific curriculum (biology examples of data
        processing that are different than physics examples of data
        processing). Of course that's been on our radar for a while,
        as it's something we talked about at some length at that
        meeting in Toronto and occasionally before then. I think it
        would be natural for us to grow toward doing something like
        that (and, arguably every time a boot camp includes a new
        example exercise we already are growing this way), so I'm not
        sure I'd say it would 'change what we do' exactly... but yes,
        I guess I'd change what we do. :)

      \item BW: The Github system has been a useful lesson for many of
	us in using Git for a fairly complex and fast-changing project.
	Perhaps we should mention of how we are applying to the course development
	the same techniques we advocate for scientific software.

    \end{itemize}

  \item MJ: Don't promote software development skills, techniques and
    tools as being essential because software developers use them and
    so the attendees should too. Rather, understand what motivates the
    attendees and promote how these skills, techniques and tools
    address these motivations (e.g. scripting $\rightarrow$ automation
    $\rightarrow$ less mistakes + free up time for research, or
    testing $\rightarrow$ spot mistakes in code $\rightarrow$ prevent
    errors being introduced into your vital data) etc.

  \item JK: It's extremely important to figure out where one sits in
    the overall pipeline of the development of computing skills for
    scientists. In other words, who/what classes or workshops come
    before you (i.e., basic programming skills, computer literacy) and
    who/what comes after you (i.e., domain specific data, advanced
    stats). It's important to be explicit about this both when
    developing content and in workshops/tutorials themselves.

  \item LN: Teach Software Carpentry \emph{before} people need to code
    for a living.

  \item EW: Teach to audiences with a common set of disciplinary
    backgrounds. This yields two benefits. First, the students are
    more likely to know each other which will make them both more
    likely to interact at the workshop and more likely to continue to
    interact after the workshop. This helps develop a culture of good
    computing practice within the group and gives students a support
    network when they run into problems. Second, the students will
    tend to have similar interests (allowing you to target the
    material; e.g. SQL vs. numerical methods) and similar
    computational backgrounds (allowing you to tailor the level of the
    material.

  \item NCH: Be careful about prioritising what's easier for the
    trainer/host, than what will have a long term benefit to the
    learners, e.g., the insistence that Windows should be
    dropped/Windows users should use non-familiar editing tools.  One
    thing that doesn't work is the follow-up assistance. Why do
    learners still find a barrier in making contact again when they
    need help?

\end{itemize}

\section{Other Notes}

\begin{itemize}

  \item EW: If you're interested in having some material on my full
    semester class included I'm happy to provide the necessary write
    up. Just let me know.

  \item BW: A section on what has {\em not} worked (yet) and other people
    should {\em not} adopt, or would require further development, would
    be interesting. We haven't had much success with online teaching or
    follow-up, for example.

\end{itemize}

\section{Citations}

\cite{hannay2009} \cite{prabhu2011} \cite{wilson1996}
\cite{wilson2006a} \cite{wilson2006b} \cite{wilson2009}

\bibliographystyle{plain}
\bibliography{software-carpentry-lessons-learned}

\end{document}
