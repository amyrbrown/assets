\documentclass{article}
\begin{document}
\title{Software Carpentry: Lessons Learned}
\date{\today}

\author{
  Azalee Bostroem (Space Telescope Science Institute / bostroem@stsci.edu)\\
  Chris Cannam (Queen Mary, University of London / chris.cannam@eecs.qmul.ac.uk)\\
  Stephen Crouch (Software Sustainability Institute / s.crouch@software.ac.uk)\\
  Matt Davis (Space Telescope Science Institute / mrdavis@stsci.edu)\\
  Luis Figueira (Queen Mary, University of London / luis.figueira@eecs.qmul.ac.uk)\\
  Richard ``Tommy'' Guy (Wave Accounting / richardtguy84@gmail.com)\\
  Edward Hart (University of British Columbia / ehart@zoology.ubc.ca)\\
  Neil Chue Hong (Software Sustainability Institute / N.ChueHong@epcc.ed.ac.uk)\\
  Katy Huff (University of  Wisconsin / khuff@cae.wisc.edu)\\
  Michael Jackson (Edinburgh Parallel Computing Centre / michaelj@epcc.ed.ac.uk)\\
  Justin Kitzes (University of California, Berkeley / jkitzes@berkeley.edu)\\
  Stephen McGough (University of Newcastle / stephen.mcgough@newcastle.ac.uk) \\
  Lex Nederbragt (University of Oslo / lex.nederbragt@ibv.uio.no)\\
  Tracy Teal (Michigan State University / tracyt@idyll.org)\\
  Ben Waugh (University College London / b.waugh@ucl.ac.uk)\\
  Lynne J. Williams (Rotman Research Institute / lwilliams@research.baycrest.org)\\
  Ethan White (Utah State University / ethan@weecology.org)\\
  Greg Wilson (Software Carpentry / gvwilson@software-carpentry.org)
}

\maketitle

\begin{abstract}
FIXME: write abstract
\end{abstract}

Between January 2012 and July 2013,
Software Carpentry ran 92 two-day workshops on basic computing skills.
More than 100 people helped over 3000 scientists learn about
program design,
task automation,
version control,
and quality assurance---the unglamorous but essential foundations
for high-performance computing,
data science,
and anything with ``cloud'' in its name.
This article summarizes how we teach,
what we've learned from doing it,
and what we plan to do next.

\section{How We Got Here}

\subsection*{Red}

In 1995--96,
Greg Wilson organized a series of articles titled,
``What Should Computer Scientists Teach to Physical Scientists and Engineers?''
\cite{wilson1996}.
The articles grew out of the frustration he felt working with scientists
who wanted to parallelize complex simulation programs
but didn't know how to modularize their code,
test it,
or track changes
\cite{wilson2006a}.
In response,
John Reynders
(then director of the Advanced Computing Laboratory at Los Alamos National Laboratory)
invited Wilson and Brent Gorda to teach
a week-long course to LANL staff.
The course ran for the first time in July 1998,
and was repeated eight times over the next four years.
It eventually wound down for two reasons:
the principal players had all moved on to other responsibilities,
and the intensive week-long format wasn't particularly effective.

\subsection*{Red}

The course materials were updated and released under a Creative Commons license in 2004--05
thanks to a grant from the Python Software Foundation \cite{wilson2006b}.
The hope was that scientists would add lessons of their own,
but it soon became clear that this wasn't going to happen:
while several thousand people visited the site each month,
only a dozen ever offered corrections,
and only three ever offered new material.
In retrospect,
this was primarily because lessons are not as well suited to mass editing
as Wikipedia-style encyclopedia entries.
Good lessons are narratives,
not merely facts presented in sequence:
editing a lesson has more in common with writing a novel
(or at least a short story).

\subsection*{Orange}

Wilson rebooted Software Carpentry in May 2010
with support from several organizations\footnote{Indiana University,
Michigan State University,
Microsoft,
MITACS,
Queen Mary University of London,
Scimatic,
SciNet,
SHARCNet,
and the UK Met Office.}.
More than 120 short video lessons were recorded during the following 12 months,
and six more week-long classes were run.
Once again,
only a handful of other people\footnote{Orion Buske, Tommy Guy, Jason Montojo, Jon Pipitone, and Ethan White.} contributed material,
and once again,
we established that five eight-hour days are more wearying than enlightening.
On the upside,
it was clear by mid-2011 that there was more demand for this kind of training than ever.

\subsection*{Green}

With new support from the Sloan Foundation and Mozilla,
Software Carpentry rebooted again in January 2012.
This time,
the model was two-day ``boot camps''
modeled on those pioneered by The Hacker Within,
a grassroots group of grad students helping grad students
at the University of Wisconsin -- Madison.
Shortening the boot camps allowed us to reach more people,
which in turn finally created
the critical mass needed to sustain online discussion.
Reaching more people also allowed us to recruit more instructors
from boot camp participants.

The results are dramatically better than previous iterations.
Software Carpentry now has over 70 qualified instructors,
runs six or seven boot camps a month,
and is almost self-sustaining.

\section{What We Do}

FIXME: describe a typical boot camp, and what we provide as support.

\section{What We Do That's Different}

\begin{itemize}

  \item KH: It's interactive and peer-taught. It's also directed at
    scientists. I don't know of anything that currently does all three
    of those things.

  \item MJ: Teaching tools and technologies by getting the attendees
    to use them, rather than telling the attendees about them. To get
    them doing things, rather than subjecting them to hour after hour
    of slides full of concepts, syntax and command-line excerpts, with
    the occasional practical thrown in like an oasis in an arid
    desert.

  \item JK: The most useful/interesting thing is providing an overall
    structural framework (i.e., the big picture) that shows scientists
    how different types of computing skills/activities fit together to
    improve their work. There are lots of workshops on data analysis
    and other specific topics, but none that I'm aware of that focus
    on describing the house in which you put the different pieces of
    furniture.

  \item LN: Change the way one thinks about going about on the
    command-line/while programming, making it much more logical,
    robust.

  \item EW: The single most interesting thing to me is our emphasis on
    having the students do a lot of hands on work even though it's
    only a two day workshop. I think this really helps the students
    stay engaged and get over the initial hurdles, and I also think
    it's not at all standard for 1-2 day workshops, which tend to be
    mostly power point and talking. On a related note I think the
    emphasis on live coding for lecture is very cool and pretty
    unique).

  \item NCH: I think it's that we teach software development as a tool
    for researchers, rather than teaching python, or git. Although, I
    notice that the opinions to this are divided on the mailing lists,
    and Steve and Mike have noted differences on the curriculums -
    only the UK courses and ones taught by you really seem to focus
    explicitly on the pedagogical teaching, and the ``why it's useful
    for my research''.

  \item ASM: Try to give a motivation for why people should do what we
    are asking them to do rather than just telling them to do so. It
    takes many software developers years to gain an appreciation on
    why we do certain things. We try to give attendees the opportunity
    to gain from our experiences rather than make the same mistakes
    themselves. However, we're talking about intelligent people here
    who want to know why we do something a particular way not just do
    it that way. In essence - continuing the Carpentry metaphor - we
    provide our apprentices with the skills of the trade but also the
    wealth of our experiences.  Alternatively, I'm really keen on the
    ``blended learning'', and having instructors type (and make
    mistakes) live.

  \item BW: Different from what? Other {\em programming} courses for
    scientists and others focus on how to write correct code,
    and give the impression that on reaching a certain level of competence
    programmers will no longer make mistakes. We accept that making
    mistakes is inevitable and teach how to detect and diagnose these.
    We also emphasise code maintainability, including readability and
    modular structure, rather than just initial construction.
    Other {\em software engineering} courses are generally not offered
    specifically to scientists, being aimed more at professional
    software developers undertaking larger projects. We show scientists
    who are not specialist programmers how these principles can pay off
    even on small projects, and relate the practices to research issues such as
    reproducibility and provenance.
    
  \item LJW: I think that the most unique thing about Software
    Carpentry is that it is user centered.  Instead of an expert
    coming in to tell us what we need to know about computing,
    Software Carpentry tries to build on what we know and tailor the
    material to the computing needs of researchers' specific
    environments.

  \item MD: We are 100\% open. Every document SWC has that could
    possibly be public is public. And we're incredibly open about
    events and feedback. Something awesome happens? Goes on the
    blog. Something bad happens? Goes on the blog. I think (hope) that
    the fact that people can see us actively succeeding, failing, and
    learning buys us some credibility and respect.

  \item RG: One thing I have learned is that our best teaching happens
    when we enable self motivated students by pointing them in the
    right direction. A graduate student who shows up at a SWC workshop
    is already more motivated than average. The biggest hurdle they
    often face is knowing \emph{what} they don't know. I think the
    most important lesson we share is how we approach a software
    problem, how we identify tools and libraries, and how we solve
    programming challenges.

  \item AB: We take text editors for granted and we shouldn't. I try
    to explicitly ask people to install as text editor and at least
    spend 5 min making sure everyone is on the same page. It may be
    worth including a note on how to exit vi since you get
    automatically sent there if you forget the -m in your Git commit
    statement and :wq is not an intuitive exit statement

  \item EH: The most useful thing I've learned is to adopt a more
    engaging teaching style.  By that I mean to abandon power point
    slides, or only use them minimally.  Instead to have students
    actually type along with me, and then break up teaching into
    manageable bits with hands on exercises.  It's way more engaging
    and especially important in a workshop setting where you're asking
    people to be in class for 8 hours or so.

  \item SC: We don't try to teach too much. We teach a selection of
    concepts, approaches, tools and techniques that we believe are
    most useful, and that offer high productivity returns on invested
    learning effort e.g. version control, testing, etc.  And building
    on MJ's first point, we aim to teach our material so that it can
    be readily applied to participant's own research, as opposed to
    teaching a high level concept-fest that isn't readily applicable.

  \item TT: Working with a lot of people now, trying to get them to
    run command line programs, I have a theory that learning all these
    other things is not that useful if you don't know how to get
    around at the command line or understand paths. Time and time
    again, things don't work because they don't have the path right,
    or don't 'ls' to look for things, or run out of hard drive space
    and don't know to 'df', or can't look at a big text file with
    'less' or 'more' or whatever.  Or don't know about up-arrow or
    auto-complete.  They're then afraid to do things or quickly hit
    road blocks when things are exactly the same as they were in the
    class.  Honestly, I don't really know how to teach the shell or
    paths, other than to just have a list of commands.  Most people I
    know who learn the shell, just learn it by doing it.

\end{itemize}

\section{What Other People Could Adopt}

\begin{itemize}

  \item KH: I like our github system. I also like your
    teaching.software-carpentry.org lessons/system/pipeline. If I were
    to warn another group I would suggest that they seek out a
    target-audience that is as domain-specific as possible.

    \begin{itemize}

      \item GW: But we \emph{don't} go domain-specific---does that
        mean you'd change what we do?

      \item KH: What I meant was that I would seek out audiences that
        are domain-specific so that any single bootcamp has a better
        chance of being attended by people with a smaller range
        strengths and weaknesses. We can do that more now (and are
        doing it a bit) just by targeted advertising of the
        bootcamps. That is, if we advertise a bootcamp only to physics
        grad students, we can more comfortably teach our curriculum
        with an emphasis on version control rather than the shell
        (since physics grad students are more comfortable in the shell
        than other disciplines). The way you read this suggestion,
        though, is also true. I do think it would be good to generate
        domain-specific curriculum (biology examples of data
        processing that are different than physics examples of data
        processing). Of course that's been on our radar for a while,
        as it's something we talked about at some length at that
        meeting in Toronto and occasionally before then. I think it
        would be natural for us to grow toward doing something like
        that (and, arguably every time a boot camp includes a new
        example exercise we already are growing this way), so I'm not
        sure I'd say it would 'change what we do' exactly... but yes,
        I guess I'd change what we do. :)

      \item BW: The Github system has been a useful lesson for many of
	us in using Git for a fairly complex and fast-changing project.
	Perhaps we should mention of how we are applying to the course development
	the same techniques we advocate for scientific software.

    \end{itemize}

  \item MJ: Don't promote software development skills, techniques and
    tools as being essential because software developers use them and
    so the attendees should too. Rather, understand what motivates the
    attendees and promote how these skills, techniques and tools
    address these motivations (e.g. scripting $\rightarrow$ automation
    $\rightarrow$ less mistakes + free up time for research, or
    testing $\rightarrow$ spot mistakes in code $\rightarrow$ prevent
    errors being introduced into your vital data) etc.

  \item JK: It's extremely important to figure out where one sits in
    the overall pipeline of the development of computing skills for
    scientists. In other words, who/what classes or workshops come
    before you (i.e., basic programming skills, computer literacy) and
    who/what comes after you (i.e., domain specific data, advanced
    stats). It's important to be explicit about this both when
    developing content and in workshops/tutorials themselves.

  \item LN: Teach Software Carpentry \emph{before} people need to code
    for a living.

  \item EW: Teach to audiences with a common set of disciplinary
    backgrounds. This yields two benefits. First, the students are
    more likely to know each other which will make them both more
    likely to interact at the workshop and more likely to continue to
    interact after the workshop. This helps develop a culture of good
    computing practice within the group and gives students a support
    network when they run into problems. Second, the students will
    tend to have similar interests (allowing you to target the
    material; e.g. SQL vs. numerical methods) and similar
    computational backgrounds (allowing you to tailor the level of the
    material.

  \item NCH: Be careful about prioritising what's easier for the
    trainer/host, than what will have a long term benefit to the
    learners, e.g., the insistence that Windows should be
    dropped/Windows users should use non-familiar editing tools.  One
    thing that doesn't work is the follow-up assistance. Why do
    learners still find a barrier in making contact again when they
    need help?

  \item MD: SWC does two-day boot camps because that's the optimized
    intersection of teaching something meaningful and
    teachers/students putting aside some time. But I would absolutely
    encourage anyone planning this kind of event to fight hard for
    more time if they can at all afford it. There's no reason to rush
    through content like we do if you could realistically spend three
    days or a week on it instead. Especially if that gives students a
    chance to apply lessons to their actual problems.

  \item CC: It's a good thing to start by working on examples that use
    plain text files as input and output.  For people in a field like
    ours (I mean audio), it initially feels kind of wrong to be
    focusing at first on text file processing -- a bit as if you're
    avoiding the real problems by not using the data that people care
    most about. But it works out well, I think, not only because it
    makes for a nice simple common basis for learning about
    programming tools, but also because it encourages a view that you
    can always get data into a transparent format and that this will
    make your life easier.  There is a risk that you end up assuming
    that everything has to be text and running into trouble with data
    that isn't expressed so readily that way, but I think the tradeoff
    is worth it.

  \item LF: From all the subjects we teach I consider Python to be the
    most controversial. When teaching Python we tend to spend too much
    time on syntax and basic programming issues instead of focusing on
    the core SWC materials (better programming skills for those who
    already know how to program). Teaching a programming language from
    scratch makes much harder to focus on good programming practices
    (even if you're teaching proficient programmers{\ldots}).  On the
    other hand, items such as version control and databases are quite
    straight to the point. They are self contained and fit very well
    in a couple of hours of teaching time. Plus: most people
    understand straight away how they can adopt (or not) them in their
    own work. As a bonus, whenever we teach how they can be used with
    the other tools we've already taught, it's usually a success (for
    instance: I'm thinking of Steve in Tuebingen querying a MySQL DB
    from a Python script in the end of the databases session, which
    made people really excited!

  \item SC: The engaging ``code with me''/regular exercise nature of
    the course allows for a high degree of adaptation and optimisation
    of the topic's delivery, andmakes it much easier to gauge progress
    and change pace or add helpful detail where required.  And
    something we've begun to do more of: a ``before'' and ``after''
    skill survey, to see how participation in Software Carpentry
    improves their skills. This allows you to see what works and what
    doesn't, and amend topics and methods appropriately for future
    courses.

\end{itemize}

\section{Other Notes}

\begin{itemize}

  \item EW: If you're interested in having some material on my full
    semester class included I'm happy to provide the necessary write
    up. Just let me know.

  \item BW: A section on what has {\em not} worked (yet) and other people
    should {\em not} adopt, or would require further development, would
    be interesting. We haven't had much success with online teaching or
    follow-up, for example.

  \item MD: We aren't just instructors. We are salespeople selling
    obtuse technobabble that looks suspiciously like extra work and
    interruptions of old habits. If we don't put value to students
    front and center it doesn't matter how flashy our presentation is,
    no one will buy unless they've already been sold by their
    friends/colleagues.

  \item CC: We've had distinctly mixed feedback about Python
    itself---not the language (the more we use it in this context the
    more appropriate and well-designed it seems) but the environment
    in terms of modules and installation. I think a few people around
    here would rather we had concentrated on MATLAB---which I'd
    personally be reluctant to do, I think the ``you won't be able to
    use it once you're out of here'' argument is a strong one.

  \item RG: The thing I still don't believe I've gotten right at a
    workshop is exercises. I'm not sure what the ``do not repeat'' is
    here, but I feel like I've hard a hard time motivating a problem
    that is interesting enough to maintain attention, challenging
    enough to push the majority of the participants, and tractable in
    a few hours.

  \item AB: Don't ask student's to copy long URLs from your
    presentation to their computers.

  \item EH: As far as what we do that others shouldn't do, I really
    think that we don't provide people with good criteria to self
    select.  I don't think we should be in the place of telling people
    they should or shouldn't attend, but I think it'd be good if we
    had self assessments where people could try and solve a problem,
    and if they can't we might say: ``You are welcome to attend but
    the pace of material may be very rapid''.  The biggest complaint
    I've seen is that people get lost to easily and once they fall
    behind it's hard for them to catch up.

  \item SC: What people shouldn't adopt: when presenting a topic, I've
    noticed it's sometimes easy to get distracted with the technical
    detail (and often very engaging related discussions!) and lose
    sight of explaining the motivations behind what is being taught,
    which I think is crucial. To prevent this, I've found it's a good
    idea to ensure a topic session is structured and timed to
    specifically include the motivation and benefit aspects as well as
    the technical material.

  \item SC: I totally agree with JK's point about knowing where SWC
    sits in the overall scheme of learning, and perhaps we should do
    more to understand and articulate this. For me, SWC sits at a
    critical point (like a nexus, or checkpoint) in the learning space
    for researchers, and once such a set of basic skills are learned
    it becomes appropriate (based on this foundation) to proceed to
    more advanced topics.

\end{itemize}

\section{Citations}

\cite{hannay2009} \cite{prabhu2011} \cite{wilson2009}

\bibliographystyle{plain}
\bibliography{software-carpentry-lessons-learned}

\end{document}
